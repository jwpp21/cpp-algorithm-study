
while(sum!=0) {
	n[sum % 10]++;
	sum /= 10;
}
// 숫자 분해 (1의 자리수 부터)

to_string() // int to string
stoi() // string to int

// 2차원 배열 초기화
int num[10][10] = {0, };

// 2차원 배열 입력 for문 이용
for(int i=0;i<10;i++){
	cin >> num[i]; // num배열 i번째 줄 전부에 입력 ex) 1303입력시 num[0][0] = 1, num[0][1] = 3 
}

// 특정 진법의 수를 10진법으로 변환 하는법
// ex) 3진법 수 102를 10진법으로 변환
// 1*3의제곱 + 0*3 + 2*3의0승 = 11 <<< 다른 진법도 마찬가지로 변환할 수 있다.

int n,sum=0;
string s;
cin >> s >> n;
for (int i = 0; i < s.size(); i++) {
	if (s[i] >= '0' && s[i] <= '9') {
		sum = sum * n + (s[i] - '0'); // 문자 '0' ~ '9' 까지의 숫자를 정수값으로 변환. 
	}
	else
		sum = sum * n + (s[i] - 'A' + 10); // 문자 'A' ~ 'Z' 까지의 문자를 정수값으로 변환. +10을 하는 이유는 10진수 이상 진법에서는 알파벳 A~Z가 11~35임.
}
cout << sum;

// 형변환
char one = 'A';
char two = '65';

cout << one;		// 출력 : A
cout << two;		// 출력 : A
cout << int(one);	// 출력 : 65

// 계산식을 거치면 int형으로 변환됨
cout << one - two;	// 출력 : 0 (두 문자 사이의 간격)

// 다른 type 변수에 저장하면 해당 type으로 바뀜
int ONE;
ONE = one;	

cout << ONE;		// 출력 : 65

// 10진수의 숫자를 n진수 숫자로 변환
while (num > 0) {
    int r = num % base; 

    if (r < 10)
        result = char(r + '0') + result;      // 0~9 숫자
    else
        result = char(r - 10 + 'A') + result; // 10~35 문자로 (A~Z)

    num /= base;
}
//나눗셈을 반복해서 나머지를 저장하고, 역순으로 출력하면 된다!

//예: 10진수 255를 16진수로 바꾸면:

//255 ÷ 16 = 15, 나머지 15 (F)

//15 ÷ 16 = 0, 나머지 15 (F)

//결과 → "FF"


// 시간 복잡도 설명 (백준 factories님 답변)
<b>
O(1) 상수 시간에 찾을 수 있는 경우 (배열에 맨 뒤에 값 추가)
O(logN) 이 경우 log의 밑은 2가 되며, 주로 이분탐색, 우선순위 큐에 값 추가나 삭제, 그리고 트리등이 포함됩니다.
O(N) 일반적으로 반복문을 N번 돌릴 때의 시간복잡도
O(NlogN) 정렬(병합정렬) 기반 알고리즘의 일반적인 시간복잡도
O(N^2) 이중 반복문 사용시 나타나는 시간복잡도
O(N!) N의 팩토리얼 번 반복할 경우, 조합, 순열등에서 사용됨.
이 외:
O(루트N*N) 에라토스테네스의 체 사용시

입력의 크기를 무언가의 값으로 나타냈다고 합시다. 보통 n이라고 합시다.

입력의 크기라는 것을 한 마디로 말하자면, 모든 입력 데이터를 처리하는데 가장 바깥쪽의 for문을 몇 번 돌아야 하는 가?라고 할 수 있습니다.

(이 문제에서는 입력의 크기가 직접 주어지고 있습니다)

----

시간복잡도에 대해서 문제 풀이자가 알아야 하는 개념은 이하에 적은 내용밖에 없습니다.

"n이 10배, 100배로 늘어날때, 프로그램의 실행 시간은 몇배로 늘어날까?"

----

이것에 대해서 "틀렸지만, 이해하는데 사용하는 정도라면 상관없는 비유"를 들자면 아래와 같습니다.

----

n이 10배, 100배로 늘어날때, 실행시간도 10배, 100배로 늘어나면 O(n)이라고 합니다.

예를 들어, 입력의 크기가 1일때 실행시간이 1초였는데

10일때는 10초라면, O(n)입니다.

----

같은 경우에 실행시간이 100배, 10000배로 늘어나면 O(n^2)이라고 합니다.

예를 들어, 입력의 크기가 1일때 실행시간이 1초였는데

10일때는 100초라면, O(n^2)입니다.

----

같은 경우에 실행시간이 +1, +2만큼 늘어나면 O(log(n))이라고 합니다.

예를 들어, 입력의 크기가 1일때 실행시간이 1초였는데

10일때는 2초라면, O(log(n))입니다.

----

같은 경우에 실행시간이 바뀌지 않으면 O(1)이라고 합니다.
예를 들어, 입력의 크기가 1일때 실행시간이 1초였는데

10일때도 1초라면, O(1)입니다.

---
c++ 에서 switch-case 문 안에서 변수를 만드려면 반드시 {} 중괄호로 감싸줘야 한다.
백준에서는 기본적으로 main 함수 내부의 지역 변수로 큰 배열을 선언하면 스택 메모리를 초과해서 컴파일 에러 또는 런타임 에러가 납니다.

최대공약수 최소 공배수
	최대공약수는 두 수 중 큰 값까지 for문 돌려서 i값으로 나눠 떨어지면 그게 최대공약수
	최소공배수는 두 수를 곱한값부터 1까지 for루프 돌려서 각 수가 i값으로 나머지 없이 나눠 떨어지면 그게 최소공배수

// cin과 getline을 같이 사용할때 cin.ignore()이 필요한 이유
cin은 '\n'를 처리하지 않고 입력버퍼에 남겨둔다.
geline은 '\n'를 입력버퍼에서 가져와서 처리한다. 
cin.ignore();는 버퍼 전체를 비우는것이 아니라 맨 앞의 문자하나를 지운다.
getline(읽어올 입력스트림, 저장할 문자열변수)


// c++ 라이브러리 활용한 중복제거 패턴
sort(vec.begin(), vec.end()); // 먼저 정렬
vec.erase(unique(vec.begin(), vec.end()), vec.end()); // 중복 제거

// 절대값 구하는 함수 <cmath>
>>> abs();

// 백분율 구하는 방법 + 반올림 함수 <cmath>
ex) 5의 15퍼센트
>>> 5 * (15/100.0)
>>> round();
