
오, 그거 진짜 **핵심을 찌르는 질문**이야.  
문제의 시간/메모리 제한을 보고 **어떤 알고리즘을 써야 하는지 감 잡는 법**, 이것만 잘 익혀도 **푼 문제 수보다 못 푼 문제 수를 줄일 수 있어.**

---

## 📌 1. 시간 제한 기준으로 "알고리즘 복잡도" 감 잡기

문제마다 시간 제한이 **보통 1초 ~ 2초** 정도야.  
**1초에 1억 번 연산(= 10^8번)** 정도가 가능하다고 가정하면,

| 입력 크기 N | 가능한 알고리즘 |
|-------------|------------------|
| ≤ 10        | 브루트포스 (순열, 재귀 완전탐색)  
| ≤ 1,000     | O(N²), O(N³) 가능  
| ≤ 10,000    | O(N log N) or O(N²) 약간  
| ≤ 100,000   | O(N log N) or O(N)  
| ≤ 1,000,000 | O(N log N), 정렬, 해시맵 등  
| ≥ 10^7 이상 | O(N) 이하, 거의 선형 시간만 허용  

---

## 📌 2. 메모리 제한 기준으로 자료구조 판단

보통 C++에서 `int`는 4바이트, `long long`은 8바이트.

| 메모리 제한 | 배열/자료구조 크기 |
|-------------|-------------------|
| 128MB       | 약 3천만 개 `int` 저장 가능  
| 256MB       | 약 6천만 개 `int`  
| 512MB       | 약 1억 개 `int` → 제한 큼  
| 1024MB~     | 거의 자유롭다고 보면 됨  

**즉, 10^6 크기의 배열은 거의 대부분의 문제에서 OK**

---

## 📌 3. 자료구조 + 알고리즘 매칭 예시

| 상황 | 자료구조 | 알고리즘 |
|------|----------|----------|
| 입력 작고 모든 경우 탐색해야 함 | 없음 or 배열 | 브루트포스, 백트래킹  
| 순서를 유지한 삽입/삭제 | 덱/큐 | 슬라이딩 윈도우, 덱  
| 정렬된 상태 유지 | `set`, `map`, `multiset` | 이진 탐색  
| 빠른 탐색 필요 | `unordered_map`, `unordered_set` | 해시  
| 최단거리 | `queue` | BFS, 다익스트라  
| 최장 증가 수열 | 배열 | DP + 이진 탐색  
| 연속합 최적화 | 누적합 배열 | 투 포인터, 슬라이딩 윈도우  

---

## 📌 예시: 1789번

- **입력**: S ≤ 4,294,967,295 (unsigned int 범위)
- **시간 제한**: 1초
- → `O(N)`까진 허용됨
- 그리디하게 1부터 더해가며 합이 `S` 이하인 수들을 찾으면 됨  
  즉, **수열이 커질수록 합이 빠르게 커지므로 O(√S)** 정도 연산이면 충분

---

## ✅ 결론: 보는 법 익히는 팁

- **입력 크기 먼저 본다** → `N의 범위` → `시간복잡도 유추`
- **시간 제한**을 보고 → 10^8번 안에 가능한지 판단
- **메모리 제한**은 너무 큰 배열, map 사용 여부 판단
- **문제 유형**은 최근에 본 유형 기반으로 감을 잡는 것도 중요

---

궁금한 문제 있으면 예시로 같이 파헤쳐볼까?
