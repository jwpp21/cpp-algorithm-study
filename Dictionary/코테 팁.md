
---

## 📌 1. 시간 제한 기준으로 "알고리즘 복잡도" 감 잡기

문제마다 시간 제한이 **보통 1초 ~ 2초** 정도야.  
**1초에 1억 번 연산(= 10^8번)** 정도가 가능하다고 가정하면,

| 입력 크기 N | 가능한 알고리즘 |
|-------------|------------------|
| ≤ 10        | 브루트포스 (순열, 재귀 완전탐색)  
| ≤ 1,000     | O(N²), O(N³) 가능  
| ≤ 10,000    | O(N log N) or O(N²) 약간  
| ≤ 100,000   | O(N log N) or O(N)  
| ≤ 1,000,000 | O(N log N), 정렬, 해시맵 등  
| ≥ 10^7 이상 | O(N) 이하, 거의 선형 시간만 허용  

---

## 📌 2. 메모리 제한 기준으로 자료구조 판단

보통 C++에서 `int`는 4바이트, `long long`은 8바이트.

| 메모리 제한 | 배열/자료구조 크기 |
|-------------|-------------------|
| 128MB       | 약 3천만 개 `int` 저장 가능  
| 256MB       | 약 6천만 개 `int`  
| 512MB       | 약 1억 개 `int` → 제한 큼  
| 1024MB~     | 거의 자유롭다고 보면 됨  

**즉, 10^6 크기의 배열은 거의 대부분의 문제에서 OK**

---

## 📌 3. 자료구조 + 알고리즘 매칭 예시

| 상황 | 자료구조 | 알고리즘 |
|------|----------|----------|
| 입력 작고 모든 경우 탐색해야 함 | 없음 or 배열 | 브루트포스, 백트래킹  
| 순서를 유지한 삽입/삭제 | 덱/큐 | 슬라이딩 윈도우, 덱  
| 정렬된 상태 유지 | `set`, `map`, `multiset` | 이진 탐색  
| 빠른 탐색 필요 | `unordered_map`, `unordered_set` | 해시  
| 최단거리 | `queue` | BFS, 다익스트라  
| 최장 증가 수열 | 배열 | DP + 이진 탐색  
| 연속합 최적화 | 누적합 배열 | 투 포인터, 슬라이딩 윈도우  

---

## 📌 예시: 1789번

- **입력**: S ≤ 4,294,967,295 (unsigned int 범위)
- **시간 제한**: 1초
- → `O(N)`까진 허용됨
- 그리디하게 1부터 더해가며 합이 `S` 이하인 수들을 찾으면 됨  
  즉, **수열이 커질수록 합이 빠르게 커지므로 O(√S)** 정도 연산이면 충분

---

## ✅ 결론: 보는 법 익히는 팁

- **입력 크기 먼저 본다** → `N의 범위` → `시간복잡도 유추`
- **시간 제한**을 보고 → 10^8번 안에 가능한지 판단
- **메모리 제한**은 너무 큰 배열, map 사용 여부 판단
- **문제 유형**은 최근에 본 유형 기반으로 감을 잡는 것도 중요

---
좋아! 바로 문제 두 개 던져볼게.  
각 문제는 "문제 조건"만 보고 자료구조 + 알고리즘을 어떻게 유추할 수 있는지 설명해줄게.

---

### ✅ 예시 1: 백준 11004번 – **K번째 수**

> - 입력  
>   N(1 ≤ N ≤ 5,000,000), K(1 ≤ K ≤ N)  
>   N개의 수 (중복 가능, 정렬 필요 없음)  
> - 출력  
>   오름차순 정렬했을 때 K번째 수 출력  
> - 제한  
>   시간: 1초 / 메모리: 512MB

🔍 **풀이 판단**:

- 정렬만 하면 되는 문제지만, N = 5백만 → `O(N log N)`까지 허용됨  
  → **정렬 알고리즘 가능 (퀵정렬, STL `sort()`)**
- 그런데 K번째 수만 필요 → 전체 정렬 불필요  
  → **퀵 셀렉션 (QuickSelect)**: `O(N)` 평균 시간  
  → 혹은 그냥 `nth_element()` STL 사용

💡 **알고리즘**: `partial sort` 또는 `QuickSelect`  
💡 **자료구조**: 배열

---

### ✅ 예시 2: 백준 1920번 – **수 찾기**

> - 입력  
>   N(1 ≤ N ≤ 100,000)  
>   N개의 정수  
>   M(1 ≤ M ≤ 100,000)  
>   M개의 정수에 대해 존재 여부 판단  
> - 제한  
>   시간: 1초

🔍 **풀이 판단**:

- 각 수에 대해 "존재 여부"를 빠르게 찾아야 함  
  - 완전 탐색 `O(N*M)` → **100,000^2 → 시간 초과**
- 대안 1: 정렬 후 이진 탐색 → `O(M log N)`
- 대안 2: set/hash set 사용 → `O(1)` 평균 탐색

💡 **알고리즘**: 이진 탐색 or 해시 탐색  
💡 **자료구조**: `set`, `unordered_set`, 정렬된 `vector`

---

📚 왜 스택을 써야 하냐?
이런 문제 특징:

"나보다 왼쪽에 있는 것 중에서"

"나보다 큰 것"을

"가장 가까운 것" 찾기

이런 조건이 나오면 → 무조건 스택을 써야 한다.

🔥 정리 한 문장
"왼쪽에서 가장 가까운 큰 값" 찾으면 무조건 스택으로 가라. 그래야 O(N)으로 깔끔하게 푼다.
