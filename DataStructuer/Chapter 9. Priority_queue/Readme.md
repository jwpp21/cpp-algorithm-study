
### 우선순위 큐
---
- 우선순위가 높은 데이터가 먼저 나간다. 큐와 기능적인 부분에선 비슷하다. 명령어 등
- 우선순위 큐는 배열, 연결리스트를 통해 구현가능하지만 가장 효율적인 구조는 히프(heap)임.
- empty, siez, top: 제일 우선순위의 값을 보여준다.push
- emplace: priorityqueue에 구조를 삽입한다. pop : priorityqueue에서 제일 우선순위의 값을 제거한다.
- swap : 두개의 priorityqueue를 swap한다.(내부를 서로 바꾼다.)
- LPT, 허프만 코드 등
- 시간 복잡도: 삽입 (logn) - 삭제 (logn) <<< 히프기준 >>> 왜? > 최악의 경우 루트노드까지 비교 vs 제일 낮은 높이까지 비교. 즉 높이에 비례함.

### 히프
---
- 완전이진트리이다.
- 최대 히프일 때 루트노드가 가장 큰 값을 가짐.
- 항상 부모노드 >= 자식노드가 성립함. <<< 최대 힙 기준
- 완전이진트리기 때문에 차례대로 번호를 붙일 수 있음.
- 인덱스를 파악하는 방법: 한 노드 k에 왼쪽 자식노드: k*2, 오른쪽 자식노드: k*2+1, 부모노드: k/2

#### 히프의 삽입
---
- 새로운 요소가 들어오면, 새로운 노드를 히프의 마지막 노드로 삽입.
- 그 후 부모노드와 비교하여 우선순위 기준에 따라 위치를 변경.

```
void insert_max_heap(HeapType *h, element item) {
  int i;
  i=++(h->heap_size);
  while(i!=1 && (item.key > h->heap[i/2].key)) {
        h->heap[i] = h->heap[i/2];
        i=i/2;
  }
  h->heap[i] = item;
}
```

#### 히프의 삭제
---
- 먼저 루트 노드가 삭제됨. (우선순위가 가장 높은 값은 항상 루트노드기 때문에)
- 그 후 말단 노드가 루트노드에 삽입됨.
- 그 후 자식노드와 비교 후 교체. >>> 최대 힙이라면 자식노드 중 더 큰 쪽과 교체

#### 히프 정렬
---
- 배열에 정렬되어있지 않은 상태로 저장되어 있는 기준에서 최대 힙에 값을 넣어주기만 하면 정렬.
- 시간 복잡도는 nlogn
- 히프 정렬이 유리한 경우는 전체 자료중 가장 큰 값 몇 개 or 가장 작은 값 몇 개만 필요한 경우

